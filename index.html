<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Information Theory Calculator</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 20px auto; padding: 20px; }
        .container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .input-section, .output-section { border: 1px solid #ccc; padding: 15px; border-radius: 8px; }
        textarea { width: 100%; height: 150px; margin: 10px 0; }
        button { padding: 8px 16px; margin: 5px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .error { color: red; margin: 10px 0; }
        .result { margin: 15px 0; }
        table { width: 100%; border-collapse: collapse; margin: 15px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    </style>
</head>
<body>
    <h1>Information Theory Calculator</h1>
    <div class="container">
        <div class="input-section">
            <h3>Input Data</h3>
            <label>Source Distribution P (JSON array):</label>
            <textarea id="sourceDist" placeholder="[0.04, 0.115, ...]"></textarea>
            
            <label>Joint Distribution Matrix (2D JSON array):</label>
            <textarea id="jointMatrix" placeholder="[[0.040, 0.013, ...], [...]]"></textarea>
            
            <div>
                <button onclick="calculateEntropy()">1. Calculate Entropy</button>
                <button onclick="calculateBinaryHuffman()">2. Binary Huffman</button>
                <button onclick="calculateTernaryHuffman()">3. Ternary Huffman</button>
                <button onclick="calculateTernaryShannonFano()">4. Ternary Shannon-Fano</button>
                <button onclick="calculateGilbertMoore()">5. Gilbert-Moore</button>
                <button onclick="calculateJointEntropy()">6. Joint Entropy</button>
                <button onclick="calculateMarginalEntropies()">7. Marginal Entropies</button>
                <button onclick="calculateConditionalEntropies()">8. Conditional Entropies</button>
                <button onclick="calculateMutualInformation()">9. Mutual Information</button>
            </div>
            <div class="error" id="errorMessage"></div>
        </div>
        
        <div class="output-section">
            <h3>Results</h3>
            <div id="results"></div>
        </div>
    </div>

<script>
class InformationTheory {
    static validateProbabilities(prob) {
        if (!Array.isArray(prob)) throw new Error("Invalid input format");
        const sum = prob.reduce((a, b) => a + b, 0);
        if (Math.abs(sum - 1) > 0.001) throw new Error(`Probabilities sum to ${sum.toFixed(3)} instead of 1`);
        if (prob.some(p => p < 0 || p > 1)) throw new Error("Probabilities must be between 0 and 1");
    }

    static entropy(probabilities) {
        this.validateProbabilities(probabilities);
        return probabilities.reduce((sum, p) => p > 0 ? sum - p * Math.log2(p) : sum, 0);
    }

    static huffmanCode(probabilities) {
        this.validateProbabilities(probabilities);
        const nodes = probabilities.map(p => ({p, code: ''}));
        const tree = [...nodes];
        
        while (tree.length > 1) {
            tree.sort((a, b) => a.p - b.p);
            const [a, b] = tree.splice(0, 2);
            tree.push({p: a.p + b.p, children: [a, b]});
        }

        const codes = {};
        function traverse(node, code = '') {
            if (node.children) {
                traverse(node.children[0], code + '0');
                traverse(node.children[1], code + '1');
            } else {
                codes[node.p] = code;
            }
        }
        traverse(tree[0]);

        const expectedLength = probabilities.reduce((sum, p) => sum + p * codes[p].length, 0);
        return {codes, expectedLength};
    }

    static ternaryHuffman(probabilities) {
        this.validateProbabilities(probabilities);
        let nodes = probabilities.map(p => ({p, code: ''}));
        
        while (nodes.length > 1) {
            nodes.sort((a, b) => a.p - b.p);
            if (nodes.length % 2 === 0) nodes.push({p: 0});
            const group = nodes.splice(0, 3);
            nodes.push({
                p: group.reduce((sum, n) => sum + n.p, 0),
                children: group
            });
        }

        const codes = {};
        function traverse(node, code = '') {
            if (node.children) {
                node.children.forEach((child, i) => {
                    if (child.p > 0) traverse(child, code + i);
                });
            } else if (node.p > 0) {
                codes[node.p] = code;
            }
        }
        traverse(nodes[0]);

        const expectedLength = probabilities.reduce((sum, p) => sum + p * codes[p].length, 0);
        return {codes, expectedLength};
    }

    // Problem 4: Ternary Shannon-Fano (Fixed Version)
static shannonFanoTernary(probabilities) {
    this.validateProbabilities(probabilities);
    const sorted = [...probabilities].sort((a, b) => b - a);
    const codes = {};

    function split(symbols, code) {
        if (symbols.length <= 1) {
            if (symbols.length === 1) codes[symbols[0]] = code;
            return;
        }

        const total = symbols.reduce((sum, p) => sum + p, 0);
        const target = total / 3;
        let group1 = [], group2 = [], group3 = [];
        let sum1 = 0, sum2 = 0, sum3 = 0;

        // Improved grouping algorithm
        for (const p of symbols) {
            if (sum1 + p <= target * 1.2 || group1.length === 0) {
                group1.push(p);
                sum1 += p;
            } else if (sum2 + p <= target * 1.2 || group2.length === 0) {
                group2.push(p);
                sum2 += p;
            } else {
                group3.push(p);
                sum3 += p;
            }
        }

        // Ensure all groups have at least one element
        if (group3.length === 0) {
            group3 = group2.splice(group2.length-1);
            sum3 = group3[0];
            sum2 -= sum3;
        }

        split(group1, code + '0');
        split(group2, code + '1');
        split(group3, code + '2');
    }

    split(sorted, '');
    const expectedLength = probabilities.reduce((sum, p) => sum + p * codes[p].length, 0);
    return {codes, expectedLength};
}

    static gilbertMoore(probabilities) {
        this.validateProbabilities(probabilities);
        const sorted = [...probabilities].sort((a, b) => b - a);
        const codes = {};
        let cumulative = 0;

        sorted.forEach(p => {
            const length = Math.ceil(-Math.log2(p)) + 1;
            const binary = (cumulative * (2 ** length)).toString(2).slice(0, length);
            codes[p] = binary.padStart(length, '0');
            cumulative += p;
        });

        const expectedLength = probabilities.reduce((sum, p) => sum + p * codes[p].length, 0);
        return {codes, expectedLength};
    }

    static jointEntropy(matrix) {
        const flat = matrix.flat();
        this.validateProbabilities(flat);
        return flat.reduce((sum, p) => p > 0 ? sum - p * Math.log2(p) : sum, 0);
    }

    static marginalEntropies(matrix) {
        const px = matrix.map(row => row.reduce((a, b) => a + b));
        const py = matrix[0].map((_, i) => matrix.reduce((a, row) => a + row[i], 0));
        return {
            Hx: this.entropy(px),
            Hy: this.entropy(py)
        };
    }

    static conditionalEntropies(matrix) {
        const px = matrix.map(row => row.reduce((a, b) => a + b));
        const py = matrix[0].map((_, i) => matrix.reduce((a, row) => a + row[i], 0));
        
        const Hyx = matrix.reduce((sum, row, i) => {
            const rowSum = px[i];
            return sum + rowSum * this.entropy(row.map(p => p / rowSum));
        }, 0);

        const Hxy = matrix[0].map((_, j) => {
            const col = matrix.map(row => row[j]);
            const colSum = py[j];
            return colSum * this.entropy(col.map(p => p / colSum));
        }).reduce((a, b) => a + b, 0);

        return {Hyx, Hxy};
    }

    static mutualInformation(matrix) {
        const {Hx, Hy} = this.marginalEntropies(matrix);
        const Hxy = this.jointEntropy(matrix);
        return Hx + Hy - Hxy;
    }
}

function showError(message) {
    document.getElementById('errorMessage').textContent = message;
}

function parseInput(id) {
    try {
        const input = document.getElementById(id).value;
        return JSON.parse(input);
    } catch (e) {
        showError(`Invalid ${id} format`);
        return null;
    }
}

function calculateEntropy() {
    const P = parseInput('sourceDist');
    if (!P) return;
    
    try {
        const result = InformationTheory.entropy(P);
        showResult(`Entropy: ${result.toFixed(4)} bits`);
    } catch (e) {
        showError(e.message);
    }
}

function calculateBinaryHuffman() {
    const P = parseInput('sourceDist');
    if (!P) return;
    
    try {
        const {codes, expectedLength} = InformationTheory.huffmanCode(P);
        const table = createCodeTable(codes, expectedLength);
        showResult(`Binary Huffman Code:<br>${table}`);
    } catch (e) {
        showError(e.message);
    }
}

function calculateTernaryHuffman() {
    const P = parseInput('sourceDist');
    if (!P) return;
    
    try {
        const {codes, expectedLength} = InformationTheory.ternaryHuffman(P);
        const table = createCodeTable(codes, expectedLength);
        showResult(`Ternary Huffman Code:<br>${table}`);
    } catch (e) {
        showError(e.message);
    }
}

function calculateTernaryShannonFano() {
    const P = parseInput('sourceDist');
    if (!P) return;
    
    try {
        const {codes, expectedLength} = InformationTheory.shannonFanoTernary(P);
        const table = createCodeTable(codes, expectedLength);
        showResult(`Ternary Shannon-Fano Code:<br>${table}`);
    } catch (e) {
        showError(e.message);
    }
}

function calculateGilbertMoore() {
    const P = parseInput('sourceDist');
    if (!P) return;
    
    try {
        const {codes, expectedLength} = InformationTheory.gilbertMoore(P);
        const table = createCodeTable(codes, expectedLength);
        showResult(`Gilbert-Moore Code:<br>${table}`);
    } catch (e) {
        showError(e.message);
    }
}

function calculateJointEntropy() {
    const matrix = parseInput('jointMatrix');
    if (!matrix) return;
    
    try {
        const result = InformationTheory.jointEntropy(matrix);
        showResult(`Joint Entropy: ${result.toFixed(4)} bits`);
    } catch (e) {
        showError(e.message);
    }
}

function calculateMarginalEntropies() {
    const matrix = parseInput('jointMatrix');
    if (!matrix) return;
    
    try {
        const {Hx, Hy} = InformationTheory.marginalEntropies(matrix);
        showResult(`H(X): ${Hx.toFixed(4)} bits<br>H(Y): ${Hy.toFixed(4)} bits`);
    } catch (e) {
        showError(e.message);
    }
}

function calculateConditionalEntropies() {
    const matrix = parseInput('jointMatrix');
    if (!matrix) return;
    
    try {
        const {Hyx, Hxy} = InformationTheory.conditionalEntropies(matrix);
        showResult(`H(Y|X): ${Hyx.toFixed(4)} bits<br>H(X|Y): ${Hxy.toFixed(4)} bits`);
    } catch (e) {
        showError(e.message);
    }
}

function calculateMutualInformation() {
    const matrix = parseInput('jointMatrix');
    if (!matrix) return;
    
    try {
        const result = InformationTheory.mutualInformation(matrix);
        showResult(`Mutual Information: ${result.toFixed(4)} bits`);
    } catch (e) {
        showError(e.message);
    }
}

function createCodeTable(codes, expectedLength) {
    let html = '<table><tr><th>Probability</th><th>Code</th><th>Length</th></tr>';
    for (const p in codes) {
        html += `<tr><td>${p}</td><td>${codes[p]}</td><td>${codes[p].length}</td></tr>`;
    }
    html += `</table><div>Expected Length: ${expectedLength.toFixed(4)} bits</div>`;
    return html;
}

function showResult(content) {
    document.getElementById('errorMessage').textContent = '';
    document.getElementById('results').innerHTML = content;
}
</script>
</body>
</html>